! ==============================================================================
! messy_mecca_tag_IC
! generated: 12-12-08 19:34:31
!
! this module is generated by imtag utility
!
! C isotopes tagging configuration: kinetics
! level: smcl
!
! source mech. equations: mecca.spc (86 reactions)
!    tagged species list: mecca.eqn (8 of 71 given species are tagged)
! #INLINE F90_GLOBAL
!
! [Gromov, MPIC, 2007-2008]
! ==============================================================================

! - general tagging parameters (as conditional defines) ------------------------

#include "messy_mecca_tag_parameters.inc"

! - configuration parameters ---------------------------------------------------

! configuration parameters

#define TAG
#define tag_IC

#define ABBR_I
#define ATOM_C
#define CLASSES_2
#define CLASS_12
#define CLASS_13

#define NO_KIE
#define SRC
#define NO_IEX

#define USE_PT

! user configuration parameters

#define INIUNIT_DELTAPM
#define xUSE_KRSIND
#define C2R_FILTER
#define I_LINMAX

! replacements:
!
! {%TIMEDATE} is 12-12-08 19:34:31
! {%CASE} is tag
! {%CMODEL} is messy_mecca
! {%ABBR} is I
! {%ATOM} is C
! {%A} is C
! {%CONF} is IC
! {%C} is IC
! {%QSPEC} is 8
! {%NSPEC} is NTCSPEC
! {%QCLASS} is 2
! {%NCLASS} is NTCCLASS
! {%QISO} is 2
! {%NISO} is NTCISO
! {%NQATOM} is QTCATOM
! {%PT} is PT#
! {%TAG} is tag_IC
! {%NTSPEC} is NTCSPEC
! {%RTIND} is RTCIND
! {%QCFLDIR} is 16
! {%QIFLDIR} is -1
! {%DBL} is tag_IC
! {%NDSPEC} is NDCSPEC
! {%RDIND} is RDCIND
! \t is 	
! \n is 


! - integration scheme ---------------------------------------------------------

#define I_LINMAX
#define xI_SIMEULER
#define xI_CASHKARP

! -----------------------------------------------------------------------------

MODULE messy_mecca_tag_IC

  USE messy_mecca_kpp ! dp, nreact, nspec, ind_*, ...

#ifdef INTERFLOW
! in case of inter-configuration molecules flow calculation (default) 
! using flow and its direction variables from messy_mecca_tag

  USE messy_mecca_tag_common
#endif


  IMPLICIT NONE

! here constants and tracers are to be defined
! data declaration

! number of tagged species, number of classes (isotopologues)
  INTEGER, PARAMETER :: NTCSPEC = 8, NTCCLASS = 2, NTCISO = 2

! isotopologues tracers indices
  INTEGER, PARAMETER :: tag_IC_CH4 = 1          ! indicated as fixed
  INTEGER, PARAMETER :: tag_IC_CH3OH = 2
  INTEGER, PARAMETER :: tag_IC_CH3O2 = 3
  INTEGER, PARAMETER :: tag_IC_CH3OOH = 4
  INTEGER, PARAMETER :: tag_IC_HCHO = 5
  INTEGER, PARAMETER :: tag_IC_CO = 6
  INTEGER, PARAMETER :: tag_IC_HCOOH = 7
  INTEGER, PARAMETER :: tag_IC_CO2 = 8

! dummy indices of species present TSL but not in the mechanism (resolves dependency problems)
  INTEGER, PARAMETER :: tag_IC_C2H6 = 0
  INTEGER, PARAMETER :: tag_IC_C2H4 = 0
  INTEGER, PARAMETER :: tag_IC_C2H2 = 0
  INTEGER, PARAMETER :: tag_IC_C2H5O2 = 0
  INTEGER, PARAMETER :: tag_IC_C2H5OOH = 0
  INTEGER, PARAMETER :: tag_IC_CH3CHO = 0
  INTEGER, PARAMETER :: tag_IC_CH3CO2H = 0
  INTEGER, PARAMETER :: tag_IC_CH3CO3 = 0
  INTEGER, PARAMETER :: tag_IC_CH3CO3H = 0
  INTEGER, PARAMETER :: tag_IC_NACA = 0
  INTEGER, PARAMETER :: tag_IC_PAN = 0
  INTEGER, PARAMETER :: tag_IC_C3H8 = 0
  INTEGER, PARAMETER :: tag_IC_C3H6 = 0
  INTEGER, PARAMETER :: tag_IC_IC3H7O2 = 0
  INTEGER, PARAMETER :: tag_IC_IC3H7OOH = 0
  INTEGER, PARAMETER :: tag_IC_LHOC3H6O2 = 0
  INTEGER, PARAMETER :: tag_IC_LHOC3H6OOH = 0
  INTEGER, PARAMETER :: tag_IC_CH3COCH3 = 0
  INTEGER, PARAMETER :: tag_IC_CH3COCH2O2 = 0
  INTEGER, PARAMETER :: tag_IC_HYPERACET = 0
  INTEGER, PARAMETER :: tag_IC_ACETOL = 0
  INTEGER, PARAMETER :: tag_IC_MGLYOX = 0
  INTEGER, PARAMETER :: tag_IC_MPAN = 0
  INTEGER, PARAMETER :: tag_IC_IC3H7NO3 = 0
  INTEGER, PARAMETER :: tag_IC_NC4H10 = 0
  INTEGER, PARAMETER :: tag_IC_LC4H9O2 = 0
  INTEGER, PARAMETER :: tag_IC_LC4H9OOH = 0
  INTEGER, PARAMETER :: tag_IC_MVK = 0
  INTEGER, PARAMETER :: tag_IC_MVKO2 = 0
  INTEGER, PARAMETER :: tag_IC_MVKOOH = 0
  INTEGER, PARAMETER :: tag_IC_MEK = 0
  INTEGER, PARAMETER :: tag_IC_LMEKO2 = 0
  INTEGER, PARAMETER :: tag_IC_LMEKOOH = 0
  INTEGER, PARAMETER :: tag_IC_BIACET = 0
  INTEGER, PARAMETER :: tag_IC_LC4H9NO3 = 0
  INTEGER, PARAMETER :: tag_IC_C5H8 = 0
  INTEGER, PARAMETER :: tag_IC_ISO2 = 0
  INTEGER, PARAMETER :: tag_IC_ISOOH = 0
  INTEGER, PARAMETER :: tag_IC_ISON = 0
  INTEGER, PARAMETER :: tag_IC_CCl4 = 0
  INTEGER, PARAMETER :: tag_IC_CH3Cl = 0
  INTEGER, PARAMETER :: tag_IC_CH3CCl3 = 0
  INTEGER, PARAMETER :: tag_IC_CF2Cl2 = 0
  INTEGER, PARAMETER :: tag_IC_CFCl3 = 0
  INTEGER, PARAMETER :: tag_IC_CH3Br = 0
  INTEGER, PARAMETER :: tag_IC_CF3Br = 0
  INTEGER, PARAMETER :: tag_IC_CF2ClBr = 0
  INTEGER, PARAMETER :: tag_IC_CHCl2Br = 0
  INTEGER, PARAMETER :: tag_IC_CHClBr2 = 0
  INTEGER, PARAMETER :: tag_IC_CH2ClBr = 0
  INTEGER, PARAMETER :: tag_IC_CH2Br2 = 0
  INTEGER, PARAMETER :: tag_IC_CHBr3 = 0
  INTEGER, PARAMETER :: tag_IC_CH3I = 0
  INTEGER, PARAMETER :: tag_IC_CH2I2 = 0
  INTEGER, PARAMETER :: tag_IC_C3H7I = 0
  INTEGER, PARAMETER :: tag_IC_CH2ClI = 0
  INTEGER, PARAMETER :: tag_IC_CH3SO3H = 0
  INTEGER, PARAMETER :: tag_IC_DMS = 0
  INTEGER, PARAMETER :: tag_IC_DMSO = 0
  INTEGER, PARAMETER :: tag_IC_CH3SO2 = 0
  INTEGER, PARAMETER :: tag_IC_CH3SO3 = 0
  INTEGER, PARAMETER :: tag_IC_CX = 0
  INTEGER, PARAMETER :: tag_IC_CY = 0

! corresponding regular <-> tagged species indices 
  INTEGER, PARAMETER :: RTCIND(NTCSPEC) = &
    (/ ind_CH4, ind_CH3OH, ind_CH3O2, ind_CH3OOH, ind_HCHO, ind_CO, ind_HCOOH, &
       ind_CO2 /)

! quantity of C atoms in corresponding taggedspecies
  INTEGER, PARAMETER :: QTCATOM(NTCSPEC) = &
    (/ 1, 1, 1, 1, 1, 1, 1, 1 /)

! number of tagged reactions
  INTEGER, PARAMETER :: NTCREAC = 15
! added passive tracers indices
  INTEGER, PARAMETER :: TRPTCIND(NTCREAC) = &
    (/ ind_PTG4101, ind_PTG4102, ind_PTG4103, ind_PTG4104, ind_PTG4105, &
       ind_PTG4106a, ind_PTG4106b, ind_PTG4107, ind_PTG4108, ind_PTG4109, &
       ind_PTG4110, ind_PTG4111, ind_PTJ4100, ind_PTJ4101a, ind_PTJ4101b /)


! there are no KIE in selected system, empty arrays are for the compatibility
! array of indices of KIE-related species
  INTEGER, PARAMETER :: NKRSPEC = 0
  INTEGER, PARAMETER :: KRSIND(NKRSPEC+1) = (/ NKRSPEC /)



! index used for substitution of isotopic fraction of total C
  INTEGER, PARAMETER :: ind_tTC = NTCSPEC+1

! -----------------------------------------------------------------------------

#ifndef INTERFLOW
! C atoms flow control and directions indices
  INTEGER, PARAMETER :: NFLCDIR = 16
  REAL(dp)           :: flow(NFLCDIR)
  INTEGER, PARAMETER, PRIVATE :: &
    CH4_sink = 1, CH3OH_sink = 2, CH3O2_CH3OH = 3, CH3O2_sink = 4, &
    CH4_CH3O2 = 5, CH3OOH_CH3O2 = 6, CH3OOH_sink = 7, CH3O2_CH3OOH = 8, &
    HCHO_sink = 9, CH3OH_HCHO = 10, CH3O2_HCHO = 11, CH3OOH_HCHO = 12, &
    CO_sink = 13, HCHO_CO = 14, HCOOH_sink = 15, CO_CO2 = 16
#else
! flow() is imported from messy_mecca_tag_common
#endif

! -----------------------------------------------------------------------------

! concentrations of isotopologues
  REAL(dp)           :: ISOC(NTCSPEC,NTCISO)

  REAL(dp)           :: TC(NTCISO)

! total C (atoms) of the regular composition
  REAL(dp)           :: TC_R

! 12C 13C tagged species arrays
  REAL(dp)           :: I12C(NTCSPEC)
  REAL(dp)           :: I13C(NTCSPEC)
    EQUIVALENCE( I12C(1),ISOC(1,1) )
    EQUIVALENCE( I13C(1),ISOC(1,2) )

! totals (atoms)
  REAL(dp)           :: T12C, T13C
    EQUIVALENCE( T12C, TC(1) )
    EQUIVALENCE( T13C, TC(2) )

! fractions (operative), +1 for TC
  REAL(dp)           :: F12C(NTCSPEC+1), &
                        F13C(NTCSPEC+1)

! -----------------------------------------------------------------------------

! runtime control parameters

! treshold value: below it species stops to sink to the others (but can receive)
!                                         x * mean cair
  REAL(dp), PARAMETER :: THRES = 1.0E-40_dp * 2.5047E+19_dp

! last "process" run steps count, requested steps count
  INTEGER             :: tag_IC_NSTEP, tag_IC_NSTEP_REQ

! # of "rejected" species (under threshold)
  INTEGER             :: tag_IC_NREJCT
  
! # of potential error due to PTs vs. A difference over 1 order of magnitude
  INTEGER             :: tag_IC_PEPTAD

! fraction of "corrected to regular" species (diagnostic) & filter threshold
  REAL(dp)            :: tag_IC_NCOR2R
  REAL(dp), PARAMETER :: THRES_C2R = 1.0E-3_dp ! (max. ratio tag/reg allowed)

! -----------------------------------------------------------------------------

  PUBLIC

  PRIVATE zerodiv

  PRIVATE THRES, THRES_C2R

#ifndef INTERFLOW
  PRIVATE flow
#endif

  PUBLIC tag_IC_update_kie
  PUBLIC tag_IC_flow_calc
  PUBLIC tag_IC_integrate
  PUBLIC tag_IC_calctotals
  PUBLIC tag_IC_correct2reg
  PUBLIC tag_IC_correct2iso

! =============================================================================

CONTAINS

! -----------------------------------------------------------------------------

  ELEMENTAL REAL(dp) FUNCTION zerodiv(what,by)
    ! safe division which gives zero when division by zero is performed
    REAL(dp), INTENT(IN) :: what, by   ! operands
    IF (by .EQ. 0.0_dp) THEN
      zerodiv = 0.0_dp
    ELSE
      zerodiv = what/by
    ENDIF
  END FUNCTION zerodiv



! -----------------------------------------------------------------------------

  SUBROUTINE tag_IC_update_kie(C, press, cair, temp)

    IMPLICIT NONE

    ! I/O
    REAL(dp), INTENT(IN) :: C(:)
    REAL(dp), INTENT(IN) :: press
    REAL(dp), INTENT(IN) :: cair
    REAL(dp), INTENT(IN) :: temp

  ! ===== KIE preparation section (coeff. update, etc.) =======================


  ! ===== calculation of KIE-correction for reac/isot =========================

  ! ----- tag_IC: flow(KIE_REAC_ISOT) corrections calculation -----


  
  END SUBROUTINE tag_IC_update_kie



! -----------------------------------------------------------------------------

  SUBROUTINE tag_IC_flow_calc(C)
    
  ! this subroutine calculates flow of C-containig molecules
  ! from one tagged species to another, plus sinks; from PTs
    
    IMPLICIT NONE

    ! I/O
    REAL(dp), INTENT(IN)  :: C(:)

#ifndef INTERFLOW
  ! ----- tag_IC: flow(FROM_TO[sink]) = SUM( PTs(FROM->TO[sink]) ) -----

  ! ----- IC: CH4 ----- WARN: indicated as fixed species
    flow(CH4_sink) = ( C(ind_PTG4101) )

  ! ----- IC: CH3OH -----
    flow(CH3OH_sink) = ( C(ind_PTG4102) )
    flow(CH3O2_CH3OH) = ( C(ind_PTG4106b) )

  ! ----- IC: CH3O2 -----
    flow(CH3O2_sink) = ( C(ind_PTG4103) + &
      C(ind_PTG4104) + C(ind_PTG4105) + 2.00_dp * C(ind_PTG4106a) + &
      2.00_dp * C(ind_PTG4106b) )
    flow(CH4_CH3O2) = ( C(ind_PTG4101) )
    flow(CH3OOH_CH3O2) = ( 0.7 * C(ind_PTG4107) )

  ! ----- IC: CH3OOH -----
    flow(CH3OOH_sink) = ( C(ind_PTG4107) + &
      C(ind_PTJ4100) )
    flow(CH3O2_CH3OOH) = ( C(ind_PTG4103) )

  ! ----- IC: HCHO -----
    flow(HCHO_sink) = ( C(ind_PTG4108) + &
      C(ind_PTG4109) + C(ind_PTJ4101a) + &
      C(ind_PTJ4101b) )
    flow(CH3OH_HCHO) = ( C(ind_PTG4102) )
    flow(CH3O2_HCHO) = ( C(ind_PTG4104) + &
      C(ind_PTG4105) + 2.0 * C(ind_PTG4106a) + &
      C(ind_PTG4106b) )
    flow(CH3OOH_HCHO) = ( 0.3 * C(ind_PTG4107) + &
      C(ind_PTJ4100) )

  ! ----- IC: CO -----
    flow(CO_sink) = ( C(ind_PTG4110) )
    flow(HCHO_CO) = ( C(ind_PTG4108) + &
      C(ind_PTG4109) + C(ind_PTJ4101a) + &
      C(ind_PTJ4101b) )

  ! ----- IC: HCOOH -----
    flow(HCOOH_sink) = ( C(ind_PTG4111) )

  ! ----- IC: CO2 -----
    flow(CO_CO2) = ( C(ind_PTG4110) )

#endif

  END SUBROUTINE tag_IC_flow_calc

! -----------------------------------------------------------------------------

! main subroutine of isotopic exchange calculation

  SUBROUTINE tag_IC_integrate(TSL, nstep, C, press, cair, temp)

! turned off so far due to incompatibility with CAABA variables management
!   USE messy_mecca_kpp, ONLY: A, SPC_NAMES, EQN_TAGS

    IMPLICIT NONE

    ! I/O
    REAL(dp), INTENT(IN) :: C(:)
    REAL(dp), INTENT(IN) :: press
    REAL(dp), INTENT(IN) :: cair
    REAL(dp), INTENT(IN) :: temp

    INTRINSIC SUM

  ! TSL = times_step_len value    
    REAL(dp), INTENT(IN) :: TSL
  
  ! number of steps to take ( = nsteps from integrator? )
    INTEGER, INTENT(IN)  :: nstep

    REAL(dp) :: tot

#ifdef I_LINMAX
    INTEGER  :: n, s, k, nok, nbad
  ! "jacobians"
    REAL(dp) :: J(NTCSPEC,NTCSPEC,NTCISO)
  ! "weights"
    REAL(dp) :: Z(NTCSPEC)

    REAL(dp) :: ITA(NTCSPEC), &
                ITR(NTCSPEC,2:NTCISO), &
                ITAR(NTCSPEC,2:NTCISO)
  ! REAL(dp) :: ISAVE(NTCSPEC,NTCISO), IDER(NTCSPEC,NTCISO)
    REAL(dp) :: delta, done
    INTEGER  :: steps
#endif

#ifdef I_SIMEULER
    INTEGER  :: n, s, nok, nbad
    REAL(dp) :: part, delta, done
    LOGICAL  :: reject, reject_last
    REAL(dp) :: ISAVE(NTCSPEC,NTCISO), IDER(NTCSPEC,NTCISO)
    REAL(dp), PARAMETER :: CLOSE_FAC = 0.2_dp, FAR_FAC = 2.0_dp
#endif

#ifdef I_CASHKARP
    INTEGER  :: n, nok, nbad
#endif

  ! ===== PROCESS section =====================================================

  ! updating total C fractions
  ! (they do not change during the integration)

  ! updating TC, comment to optimize
  ! CALL tag_IC_calctotals
    tot = T12C + T13C
    IF (tot /= 0.0_dp) THEN
      F12C(ind_tTC) = T12C / tot
      F13C(ind_tTC) = T13C / tot
    ELSE
      F12C(ind_tTC) = 0.0_dp
      F13C(ind_tTC) = 0.0_dp
    ENDIF

! turned off so far due to incompatibility with CAABA variables management
  ! checking A() and PTs correspondence
!   tag_IC_PEPTAD = 0
!   DO n = 1, NTCREAC
!     IF ( ( A(TRPTCIND(n,2)) / (C(TRPTCIND(n,1))/TSL) ) .LT.  0.1_dp ) THEN
#ifdef DEBUG
!       print *,'tag_IC_process: A << PT: ',TRIM(EQN_TAGS(TRPTCIND(n,1)))
#endif
!       tag_IC_PEPTAD = tag_IC_PEPTAD + 1
!     ENDIF
!     IF ( ( A(TRPTCIND(n,2)) / (C(TRPTCIND(n,1))/TSL) ) .GT. 10.0_dp ) THEN
#ifdef DEBUG
!       print *,'tag_IC_process: A >> PT: ',TRIM(EQN_TAGS(TRPTCIND(n,1)))
#endif
!       tag_IC_PEPTAD = tag_IC_PEPTAD + 1
!     ENDIF
!   ENDDO

  ! ----- main calculation cycle ------------------------------------

#ifndef INTERFLOW
  ! calculate C molecules flow through PTs (or A)
    CALL tag_IC_flow_calc(C)
    
    CALL tag_IC_update_kie(C, press, cair, temp)
#endif

#ifdef I_LINMAX
! >>>>> LINEAR-MATRIX integration scheme >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

    tag_IC_NREJCT = 0

  ! filtering "below-threshold" species  (also an optimisation issue?)
!    DO n = 1, NTCSPEC
!      tot = I12C(n) + I13C(n)                ! summing 12C+13C
!      IF (tot .LT. THRES) THEN
!        I12C(n) = 0.0_dp; I13C(n) = 0.0_dp
!        tag_IC_NREJCT = tag_IC_NREJCT + 1
!      ENDIF
!    ENDDO

  ! ----- setting up jacobians -----

  ! setup without inversion

    CALL prepare_Z(0,TSL)                    ! prepare weights:    type 1 2 3 4 5
    CALL prepare_J(.FALSE.)                  ! prepare "major jacobian"

  ! filling the minor matrices
    DO k = 2, NTCISO
      J(:,:,k) = J(:,:,1)
    ENDDO

  ! ----- accounting KIE -----

  ! prepairing "minor jacobian(s)"




  ! ----- integration loop -----

  ! ----- stepping -----

    done = 0.0_dp
    DO n = 1, NTCSPEC
!     delta = MAXVAL(J(n,:,1),MASK=(J(n,:,1) .GT. 0))/MINVAL(J(n,:,1), MASK=(J(n,:,1) .GT. 0.0_dp))
      delta = MAXVAL(J(n,:,1),MASK=(J(n,:,1) .GT. 0))/MINVAL(J(n,:,1), MASK=(J(n,:,1) .GT. 0.0_dp))/C(TRPTIND(n))
      IF (delta .GT. done) done = delta
    ENDDO

!    steps = INT(2*1.0E5 * done**2.71)
!    steps = INT(5.0E3 * done)
    IF (steps .LT. 10) steps = 10
    IF (steps .GT. 10000) steps = 10000

    steps = 100000
    
    delta = TSL / steps
      
    DO s = 1, steps 

    ! getting the fractions of isotopologues
      DO n = 1, NTCSPEC
        tot = SUM(ISOC(n,:))                 ! summing spec 
        IF (tot .EQ. 0.0_dp) THEN
          F12C(n) = 0.0_dp; F13C(n) = 0.0_dp
          tag_IC_NREJCT = tag_IC_NREJCT + 1
        ELSE
          F12C(n) = (ISOC(n,1) / tot)
          F13C(n) = (ISOC(n,2) / tot)
        ENDIF
      ENDDO

      ISOC(:,1)  = ISOC(:,1)  + delta * MATMUL(J(:,:,1),F12C(1:NTCSPEC))
      ISOC(:,2)  = ISOC(:,2)  + delta * MATMUL(J(:,:,2),F13C(1:NTCSPEC))

    ! filtering negative concentrations 
      DO n = 1, NTCSPEC
        DO k = 1, NTCISO    
          IF (ISOC(n,k) .LT. 0.0_dp) THEN
          print *,'tag_IC_integrate: ',TRIM(SPC_NAMES(RTCIND(n))),', class #',k,&
	          ' is negative = ',ISOC(n,k)
          ISOC(n,k) = 0.0_dp
          ENDIF
	ENDDO
      ENDDO
      
      done = done + delta

    ENDDO

  ! ----- finalizing -----

!    CALL tag_IC_calcdeltas

!    print *,' DD13,DC = ',D13C(ind_tCH3O2)-(C(ind_I13CH3O2)/C(ind_I12CH3O2)/VPDB_13C-1.0_dp)*1000.0_dp, &
!            ' ',I12C(ind_tCH3O2)+I13C(ind_tCH3O2)-C(ind_CH3O2)

    tag_IC_NSTEP = steps
    tag_IC_NREJCT = tag_IC_NREJCT / tag_IC_NSTEP

    ! necessary for this integrator
!    CALL tag_IC_correct2reg(C)
    
! <<<<< LINEAR-MATRIX integration scheme <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#endif


#ifdef I_SIMEULER
! >>>>> Simple Euler integration scheme >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  ! partitioning = 1/nstep
    part = 1.0_dp / DBLE(nstep)

    tag_IC_NREJCT = 0   ! # of rejected species
    tag_IC_NSTEP  = 0   ! # of calculation steps made
    
    delta = part        ! assume first suggested delta = partitioning
    reject = .FALSE.; reject_last = .FALSE.
    done = 0.0_dp
    nok = 0; nbad = 0

    DO WHILE (done .LT. 1.0_dp)

#ifdef DEBUG    
      print *, 'step = ',tag_IC_NSTEP+1,'   done = ',done,'   delta = ',delta
#endif

      IF (.NOT. reject) THEN
      ! normal case
      !
      ! saving tracers (except TC)
        ISAVE = ISOC 
      ELSE
      ! overshooting case, perivous step was rejected
      !
      ! restoring tracers and calculating again with a new delta
        ISOC = ISAVE 
      ENDIF

    ! calculating new isotopologues budgets

      CALL iderivs(0.0_dp, ISOC, IDER)
      ISOC(:,:) = ISOC(:,:) + delta * IDER(:,:)

    ! overshoot check
      reject = .FALSE.
      DO n = 1, NTCISO
        DO s = 1, NTCSPEC
          IF ( ISOC(s,n) .LT. 0.0_dp )  THEN
          ! step is rejected
            reject = .TRUE.
            reject_last = .TRUE.
  
          ! choosing new, smaller delta from all overshooted:
          !
          ! to reach >0, delta should be scaled down,
          ! new delta <= -delta * P/(I-P), among all isotopologues
          !
            delta = DMIN1(delta, 1.0_dp-done, &
                          -CLOSE_FAC * delta * ISAVE(s,n) &
                         / ( ISOC(s,n) - ISAVE(s,n) ) )
          ENDIF
        ENDDO
      ENDDO

    ! prepairing new step
      IF (.NOT. reject) THEN
        done = done + delta

      ! assume next suggested delta = partitioning,
      ! or the rest if part goes beyond the calculation interval (1.0)
        IF (reject_last) THEN
          delta = DMIN1(delta, 1.0_dp-done)
          reject_last = .FALSE.
        ELSE
          delta = delta * FAR_FAC
      delta = DMIN1(delta, 1.0_dp-done)
        ENDIF

        nok = nok + 1
      ELSE
        nbad = nbad + 1
      ENDIF

    ENDDO        !   (WHILE)

    tag_IC_NSTEP = nok + nbad
    tag_IC_NREJCT = tag_IC_NREJCT / tag_IC_NSTEP

! <<<<< Simple Euler integration scheme <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#endif

#ifdef I_CASHKARP
! >>>>> CASH-KARP RK integration scheme >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                                              
  ! calling integrator                                                        
    CALL rkckintegrate(ISOC, &                                          
                       0.0_dp, 1.0_dp, 1.0E-7_dp, &                           
                       1.0_dp/DBLE(nstep), 0.0_dp, &                          
                       nok, nbad)                                             
                                                                              
  ! run-control parameters                                                    
    tag_IC_NSTEP = nok + nbad      ! # of integration steps made              
                                                                              
    ! # of rejected species (approx.: C-K takes derivatives 6 times per step) 
    IF ( tag_IC_NSTEP /= 0 ) THEN                                             
      tag_IC_NREJCT = tag_IC_NREJCT / ( tag_IC_NSTEP * 6 )                    
    ELSE                                                                      
      tag_IC_NREJCT = 0                                                       
    ENDIF                                                                     
                                                                              
! <<<<< CASH-KARP RK integration scheme <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#endif

  ! CALL tag_IC_correct2reg(C)
  ! CALL tag_IC_calctotals(C)
  ! CALL tag_IC_calcdeltas

  ! run-control parameters                                                    
    tag_IC_NSTEP_REQ = nstep       ! # of requested steps                     

#ifdef DEBUG
    print *,'tag_IC_integrate: passed, req: ',tag_IC_NSTEP_REQ, &
                                    ', steps: ', tag_IC_NSTEP, &
                                    ', rej: ', tag_IC_NREJCT
#endif 

  CONTAINS

  ! ----------------------------------------------------------------------------


    SUBROUTINE iderivs(t,IVI,IDO)

    ! Subroutine iderivs returns isotopologues derivatives in IDO(), using 
    ! the starting values from IVI(), PTs and flow() at the moment t (which
    ! actually is not used)

      IMPLICIT NONE

      INTRINSIC SUM
      
      REAL(dp), INTENT(IN)  :: t 
      REAL(dp), INTENT(IN)  :: IVI(NTCSPEC,NTCISO)
      REAL(dp), INTENT(OUT) :: IDO(NTCSPEC,NTCISO)
  
      REAL(dp)              :: tot
      INTEGER               :: i

      ! getting the fractions of isotopologues
        DO i = 1, NTCSPEC
          tot = SUM(IVI(i,:))    ! summing spec 
          IF (tot .LT. THRES) THEN
!         IF (tot .NE. 0.0_dp) THEN
            F12C(i) = 0.0_dp; F13C(i) = 0.0_dp
            tag_IC_NREJCT = tag_IC_NREJCT + 1
          ELSE
            F12C(i) = (IVI(i,1) / tot)
            F13C(i) = (IVI(i,2) / tot)
          ENDIF
        ENDDO

      ! calculating 12C 13C isotopologues derivatives

    ! ===== tag_IC: IDO(tag_IC_#,1) <- ( F12C(tag_IC_#)*flow() + ... ) =====

      ! ----- CH4 -----  WARN: indicated as fixed species
      IDO(tag_IC_CH4,1) = ( &
        -   F12C(tag_IC_CH4) * ( flow(CH4_sink) ) )

      ! ----- CH3OH -----
      IDO(tag_IC_CH3OH,1) = ( &
        - F12C(tag_IC_CH3OH) * ( flow(CH3OH_sink) )  &
        + F12C(tag_IC_CH3O2) * ( flow(CH3O2_CH3OH) ) )

      ! ----- CH3O2 -----
      IDO(tag_IC_CH3O2,1) = ( &
        - F12C(tag_IC_CH3O2) * ( flow(CH3O2_sink) )  &
        +   F12C(tag_IC_CH4) * ( flow(CH4_CH3O2) )  &
        + F12C(tag_IC_CH3OOH) * ( flow(CH3OOH_CH3O2) ) )

      ! ----- CH3OOH -----
      IDO(tag_IC_CH3OOH,1) = ( &
        - F12C(tag_IC_CH3OOH) * ( flow(CH3OOH_sink) )  &
        + F12C(tag_IC_CH3O2) * ( flow(CH3O2_CH3OOH) ) )

      ! ----- HCHO -----
      IDO(tag_IC_HCHO,1) = ( &
        -  F12C(tag_IC_HCHO) * ( flow(HCHO_sink) )  &
        + F12C(tag_IC_CH3OH) * ( flow(CH3OH_HCHO) )  &
        + F12C(tag_IC_CH3O2) * ( flow(CH3O2_HCHO) )  &
        + F12C(tag_IC_CH3OOH) * ( flow(CH3OOH_HCHO) ) )

      ! ----- CO -----
      IDO(tag_IC_CO,1) = ( &
        -    F12C(tag_IC_CO) * ( flow(CO_sink) )  &
        +  F12C(tag_IC_HCHO) * ( flow(HCHO_CO) ) )

      ! ----- HCOOH -----
      IDO(tag_IC_HCOOH,1) = ( &
        - F12C(tag_IC_HCOOH) * ( flow(HCOOH_sink) ) )

      ! ----- CO2 -----
      IDO(tag_IC_CO2,1) = ( &
        +    F12C(tag_IC_CO) * ( flow(CO_CO2) ) )
                                         
    ! ===== tag_IC: IDO(tag_IC_#,2) <- ( F13C(tag_IC_#)*flow() + ... ) =====

      ! ----- CH4 -----  WARN: indicated as fixed species
      IDO(tag_IC_CH4,2) = ( &
        -   F13C(tag_IC_CH4) * ( flow(CH4_sink) ) )

      ! ----- CH3OH -----
      IDO(tag_IC_CH3OH,2) = ( &
        - F13C(tag_IC_CH3OH) * ( flow(CH3OH_sink) )  &
        + F13C(tag_IC_CH3O2) * ( flow(CH3O2_CH3OH) ) )

      ! ----- CH3O2 -----
      IDO(tag_IC_CH3O2,2) = ( &
        - F13C(tag_IC_CH3O2) * ( flow(CH3O2_sink) )  &
        +   F13C(tag_IC_CH4) * ( flow(CH4_CH3O2) )  &
        + F13C(tag_IC_CH3OOH) * ( flow(CH3OOH_CH3O2) ) )

      ! ----- CH3OOH -----
      IDO(tag_IC_CH3OOH,2) = ( &
        - F13C(tag_IC_CH3OOH) * ( flow(CH3OOH_sink) )  &
        + F13C(tag_IC_CH3O2) * ( flow(CH3O2_CH3OOH) ) )

      ! ----- HCHO -----
      IDO(tag_IC_HCHO,2) = ( &
        -  F13C(tag_IC_HCHO) * ( flow(HCHO_sink) )  &
        + F13C(tag_IC_CH3OH) * ( flow(CH3OH_HCHO) )  &
        + F13C(tag_IC_CH3O2) * ( flow(CH3O2_HCHO) )  &
        + F13C(tag_IC_CH3OOH) * ( flow(CH3OOH_HCHO) ) )

      ! ----- CO -----
      IDO(tag_IC_CO,2) = ( &
        -    F13C(tag_IC_CO) * ( flow(CO_sink) )  &
        +  F13C(tag_IC_HCHO) * ( flow(HCHO_CO) ) )

      ! ----- HCOOH -----
      IDO(tag_IC_HCOOH,2) = ( &
        - F13C(tag_IC_HCOOH) * ( flow(HCOOH_sink) ) )

      ! ----- CO2 -----
      IDO(tag_IC_CO2,2) = ( &
        +    F13C(tag_IC_CO) * ( flow(CO_CO2) ) )

    END SUBROUTINE iderivs

  ! ----------------------------------------------------------------------------

#ifdef I_LINMAX
! >>>>> LINEAR-MATRIX integration scheme >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

    SUBROUTINE prepare_Z(akind,stepping)

      IMPLICIT NONE
      
      INTRINSIC SUM

      INTEGER, INTENT(in) :: akind           ! "weighting": fractions of current & already calculated budgets
      REAL(dp), INTENT(in) :: stepping       ! # of steps

      ! coefficients are chosen empirically, need to understand
      SELECT CASE (akind)
      CASE (0)
        Z(:) = 1.0_dp
      CASE (1)
        Z(:) = SUM(ISOC(:,:),DIM=2)
      CASE (2)
        Z(:) = 0.75_dp * SUM(ISOC(:,:),DIM=2) + 0.25_dp * C(RTCIND(:))
      CASE DEFAULT     ! or 3
        Z(:) = 0.5_dp * (SUM(ISOC(:,:),DIM=2) + C(RTCIND(:)))
      CASE (4)
        Z(:) = 0.25_dp * SUM(ISOC(:,:),DIM=2) + 0.75_dp * C(RTCIND(:))
      CASE (5)
        Z(:) = C(RTCIND(:))
      END SELECT
      
      Z(:) = Z(:) * stepping

    END SUBROUTINE prepare_Z
    
  ! ---------------------------------------------------------------------------

    SUBROUTINE prepare_J(do_inv)

      IMPLICIT NONE
      
      LOGICAL, INTENT(in) :: do_inv          ! do a preparation for a further J inversion? 
                                             !   i.e. J = (I - J/stepping)    -> ^(-1)
      INTEGER :: n

      J(:,:,1) = 0.0_dp

      ! weights (Z) should be defined by this moment

      J(tag_IC_CH4,tag_IC_CH4,1) = zerodiv(-flow(CH4_sink),Z(tag_IC_CH4))
      J(tag_IC_CH3O2,tag_IC_CH4,1) = zerodiv(+flow(CH4_CH3O2),Z(tag_IC_CH4))
      J(tag_IC_CH3OH,tag_IC_CH3OH,1) = zerodiv(-flow(CH3OH_sink),Z(tag_IC_CH3OH))
      J(tag_IC_HCHO,tag_IC_CH3OH,1) = zerodiv(+flow(CH3OH_HCHO),Z(tag_IC_CH3OH))
      J(tag_IC_CH3OH,tag_IC_CH3O2,1) = zerodiv(+flow(CH3O2_CH3OH),Z(tag_IC_CH3O2))
      J(tag_IC_CH3O2,tag_IC_CH3O2,1) = zerodiv(-flow(CH3O2_sink),Z(tag_IC_CH3O2))
      J(tag_IC_CH3OOH,tag_IC_CH3O2,1) = zerodiv(+flow(CH3O2_CH3OOH),Z(tag_IC_CH3O2))
      J(tag_IC_HCHO,tag_IC_CH3O2,1) = zerodiv(+flow(CH3O2_HCHO),Z(tag_IC_CH3O2))
      J(tag_IC_CH3O2,tag_IC_CH3OOH,1) = zerodiv(+flow(CH3OOH_CH3O2),Z(tag_IC_CH3OOH))
      J(tag_IC_CH3OOH,tag_IC_CH3OOH,1) = zerodiv(-flow(CH3OOH_sink),Z(tag_IC_CH3OOH))
      J(tag_IC_HCHO,tag_IC_CH3OOH,1) = zerodiv(+flow(CH3OOH_HCHO),Z(tag_IC_CH3OOH))
      J(tag_IC_HCHO,tag_IC_HCHO,1) = zerodiv(-flow(HCHO_sink),Z(tag_IC_HCHO))
      J(tag_IC_CO,tag_IC_HCHO,1) = zerodiv(+flow(HCHO_CO),Z(tag_IC_HCHO))
      J(tag_IC_CO,tag_IC_CO,1) = zerodiv(-flow(CO_sink),Z(tag_IC_CO))
      J(tag_IC_CO2,tag_IC_CO,1) = zerodiv(+flow(CO_CO2),Z(tag_IC_CO))
      J(tag_IC_HCOOH,tag_IC_HCOOH,1) = zerodiv(-flow(HCOOH_sink),Z(tag_IC_HCOOH))

    END SUBROUTINE prepare_J

  ! - some linear algebra routines --------------------------------------------

    SUBROUTINE inverse(M,n)

      IMPLICIT NONE

      INTEGER, INTENT(IN) :: n
      REAL(dp), INTENT(INOUT) :: M(n,n)

      INTEGER  :: indx(n), i
      REAL(dp) :: E(n,n), d

      E(:,:)=0.0_dp
      DO i = 1, n                    ! setting up identity matrix
         E(i,i)=1.0_dp
      ENDDO

      CALL ludcmp(M,indx,d,n)        ! decomposing matrix just once
      DO i = 1, n                    ! finding inverse by columns
         CALL lubksb(M,indx,E(:,i),n)
!                           E(1,i)
      ENDDO

      M = E

    END SUBROUTINE inverse

  ! ---------------------------------------------------------------------------

    SUBROUTINE ludcmp(a,indx,d,n)
  
      IMPLICIT NONE
  
      INTEGER, INTENT(IN) :: n
      REAL(dp), INTENT(INOUT) :: a(n,n)
  
      REAL(dp), INTENT(OUT)   :: d
      INTEGER, INTENT(OUT)    :: indx(n)
  
      REAL(dp), PARAMETER :: TINY = 1.0E-20_dp      ! a small number.
  
    ! Given a matrix a(1:n,1:n), with physical dimension np by np, this routine replaces it by
    ! the LU decomposition of a rowwise permutation of itself. a and n are input. a is output,
    ! arranged as in equation (2.3.14) above; indx(1:n) is an output vector that records the
    ! row permutation effected by the partial pivoting; d is output as +-1 depending on whether
    ! the number of row interchanges was even or odd, respectively. This routine is used in
    ! combination with lubksb to solve linear equations or invert a matrix.
  
      INTEGER  :: i, imax, j, k
      REAL(dp) :: aamax, dum, sum, &
                  vv(n) ! vv stores the implicit scaling of each row.
  
      d=1.0_dp                 ! No row interchanges yet.
  
      DO i=1,n                 ! Loop over rows to get the implicit scaling information
        aamax=0.0_dp
        DO j=1,n
          IF (ABS(a(i,j)) .GT. aamax) aamax=ABS(a(i,j))
        ENDDO
      IF (aamax .EQ.0.0_dp ) pause 'singular matrix in ludcmp' ! No nonzero largest element.
      vv(i)=1.0_dp /aamax              ! Save the scaling.
      ENDDO
  
      DO j=1,n                 ! This is the loop over columns of Crout's method.
        DO i=1,j-1             ! This is equation (2.3.12) except for i = j.
          sum=a(i,j)
          DO k=1,i-1
            sum=sum-a(i,k)*a(k,j)
          ENDDO
          a(i,j)=sum
        ENDDO
        aamax=0.0_dp ! Initialize for the search for largest pivot element.
        DO i=j,n               ! This is i = j of equation (2.3.12) and i = j+1: ::N
          sum=a(i,j)              ! of equation (2.3.13).
          DO k=1,j-1
            sum=sum-a(i,k)*a(k,j)
          ENDDO
          a(i,j)=sum
          dum=vv(i)*ABS(sum)       ! Figure of merit for the pivot.
          IF (dum .GE. aamax) THEN ! Is it better than the best so far?
            imax=i
            aamax=dum
          ENDIF
        ENDDO
        IF (j .NE. imax) THEN     ! DO we need to interchange rows?
          DO k=1,n             ! Yes, DO so...
            dum=a(imax,k)
            a(imax,k)=a(j,k)
            a(j,k)=dum
          ENDDO
          d=-d                    ! ...and change the parity of d.
          vv(imax)=vv(j)          ! Also interchange the scale factor.
        ENDIF
        indx(j)=imax
        IF (a(j,j) .EQ.0.0_dp ) a(j,j)=TINY
    ! IF the pivot element is zero the matrix is singular 
    ! (at least to the precision of the algorithm).
    ! For some applications on singular matrices, 
    ! it is desirable to substitute TINY for zero.
        IF (j .NE. n) THEN        ! Now, finally, divide by the pivot element.
          dum=1.0_dp /a(j,j)
          DO i=j+1,n
            a(i,j)=a(i,j)*dum
          ENDDO
        ENDIF
      ENDDO                    ! Go back for the next column in the reduction.
      return
    END SUBROUTINE ludcmp
  
    ! --------------------------------------------------------------------------
  
    SUBROUTINE lubksb(a,indx,b,n)
    
      IMPLICIT NONE

      INTEGER, INTENT(IN) :: n
      REAL(dp), INTENT(IN) :: a(n,n)
      INTEGER,  INTENT(IN) :: indx(n)
      REAL(dp), INTENT(INOUT) :: b(n)
  
    ! Solves the set of n linear equations A * X = B. Here a is input, not as the matrix A but
    ! rather as its LU decomposition, determined by the routine ludcmp. indx is input as the
    ! permutation vector returned by ludcmp. b(1:n) is input as the right-hand side vector B,
    ! and returns with the solution vector X. a, n, np, and indx are not modifed by this routine
    ! and can be left in place for successive calls with different right-hand sides b. This 
    ! routine takes into account the possibility that b will begin with many zero elements, 
    ! so it is efficient for use in matrix inversion.
    
      INTEGER i,ii,j,ll
      REAL sum
      ii=0  ! When ii is set to a positive value, it will become the index
            ! of the first nonvanishing element of b. We now DO
            ! the forward substitution, equation (2.3.6). The only new
            ! wrinkle is to unscramble the permutation as we go.
      DO i=1, n
        ll=indx(i)
        sum=b(ll)
        b(ll)=b(i)
        IF (ii .NE. 0) THEN
          DO j = ii, i-1
            sum=sum-a(i,j)*b(j)
          ENDDO 
        ELSE IF (sum .NE.0.0_dp ) THEN
          ii=i ! A nonzero element was encountered, so from now on we will
               ! have to DO the sums in the loop above
        ENDIF
        b(i)=sum
      ENDDO
  
      DO i = n, 1, -1     ! Now we do the backsubstitution, equation (2.3.7).
        sum=b(i)
        DO j = i+1, n
          sum=sum-a(i,j)*b(j)
        ENDDO
        b(i)=sum/a(i,i)  ! Store a component of the solution vector X.
      ENDDO
    
      return             ! All done!
    
    END SUBROUTINE lubksb

  ! ----------------------------------------------------------------------------

! <<<<< LINEAR-MATRIX integration scheme <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#endif
    
#ifdef I_CASHKARP
! >>>>> CASH-KARP RK integration scheme >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

    SUBROUTINE cashkarp(IVI,IDI,t,h,IVO,IER)   
    
      IMPLICIT NONE
    
      REAL(dp), INTENT(IN)  :: h, t           
      REAL(dp), INTENT(IN)  :: IVI(NTCSPEC,NTCISO), IDI(NTCSPEC,NTCISO)
      REAL(dp), INTENT(OUT) :: IVO(NTCSPEC,NTCISO), IER(NTCSPEC,NTCISO)
    
  ! using the 5th-order Cash-Karp Runge-Kutta method to advance the solution over an 
  ! interval h and return the incremented variables as IVO; also return an estimate 
  ! of the IVO local truncation error IER using the embedded fourth-order method
  ! 
  ! input: 
  ! :values for NTCSPEC variables IVI and their derivatives IDI known at t
  ! h: advance interval
  !
  ! output: 
  ! IVO and IER: vectors of new values and estimated error
  !
  ! iderivs returns the right-hand side derivatives using isotopologues concentrations 
  ! from IVT and PTs

      REAL(dp)            :: IVT(NTCSPEC,NTCISO)      ! temp

      REAL(dp), DIMENSION(NTCSPEC,NTCISO) :: AK2, AK3, AK4, AK5, AK6
      REAL(dp), PARAMETER ::  A2 = 0.2_dp, &
                              A3 = 0.3_dp, &
                              A4 = 0.6_dp, &
                              A5 = 1.0_dp, &
                              A6 = 0.875_dp, &
                             B21 = 0.2_dp, &
                             B31 = 3.0_dp/40.0_dp, &
                             B32 = 9.0_dp/40.0_dp, &
                             B41 = 0.3_dp, &
                             B42 = -0.9_dp, &
                             B43 = 1.2_dp, &
                             B51 = -11.0_dp/54.0_dp, &
                             B52 = 2.5_dp, &
                             B53 = -70.0_dp/27.0_dp, &
                             B54 = 35.0_dp/27.0_dp, &
                             B61 = 1631.0_dp/55296.0_dp, &
                             B62 = 175.0_dp/512.0_dp, &
                             B63 = 575.0_dp/13824.0_dp, &
                             B64 = 44275.0_dp/110592.0_dp, &
                             B65 = 253.0_dp/4096.0_dp, &
                              C1 = 37.0_dp/378.0_dp, &
                              C3 = 250.0_dp/621.0_dp, &
                              C4 = 125.0_dp/594.0_dp, &
                              C6 = 512.0_dp/1771.0_dp, &
                             DC1 = C1-2825.0_dp/27648.0_dp, &
                             DC3 = C3-18575.0_dp/48384.0_dp, &
                             DC4 = C4-13525.0_dp/55296.0_dp, &
                             DC5 = -277.0_dp/14336.0_dp, &
                             DC6 = C6-0.25

    ! First step.
      IVT(:,:) = IVI(:,:)+h*(B21*IDI(:,:))
      CALL iderivs(t+A2*h,IVT,AK2)        ! Second step.

      IVT(:,:) = IVI(:,:)+h*(B31*IDI(:,:)+B32*AK2(:,:))
      CALL iderivs(t+A3*h,IVT,AK3)        ! Third step.

      IVT(:,:) = IVI(:,:)+h*(B41*IDI(:,:)+B42*AK2(:,:)+B43*AK3(:,:))
      CALL iderivs(t+A4*h,IVT,AK4)        ! Fourth step.

      IVT(:,:) = IVI(:,:)+h*(B51*IDI(:,:)+B52*AK2(:,:)+B53*AK3(:,:)+B54*AK4(:,:))
      CALL iderivs(t+A5*h,IVT,AK5)        ! Fifth step.

      IVT(:,:) = IVI(:,:)+h*(B61*IDI(:,:)+B62*AK2(:,:)+B63*AK3(:,:)+B64*AK4(:,:)+B65*AK5(:,:))
      CALL iderivs(t+A6*h,IVT,AK6)        ! Sixth step.
    
    ! output:

    ! accumulating increments with proper weights
      IVO(:,:) = IVI(:,:)+h*(C1*IDI(:,:)+C3*AK3(:,:)+C4*AK4(:,:)+C6*AK6(:,:))    
    
    ! Estimate error as difference between fourth and fifth order methods.
      IER(:,:) = h*(DC1*IDI(:,:)+DC3*AK3(:,:)+DC4*AK4(:,:)+DC5*AK5(:,:)+DC6*AK6(:,:))
    
!     RETURN
    
    END SUBROUTINE cashkarp
    
  ! ---------------------------------------------------------------------------

  ! stepper calls the cashkarp to take a Cash-Karp Runge-Kutta step:

    SUBROUTINE stepper(IVIO,IDI,t,htry,eps,ESC,hdid,hnext) ! +n,derivs
  
      IMPLICIT NONE
  
      REAL(dp), INTENT(INOUT) :: t, IVIO(NTCSPEC,NTCISO)
      REAL(dp), INTENT(OUT)   :: hdid, hnext
      REAL(dp), INTENT(IN)    :: IDI(NTCSPEC,NTCISO), &
                                 ESC(NTCSPEC,NTCISO), &      ! error scale
                                 htry, eps
  
    ! fifth-order Runge-Kutta stepper with monitoring of local truncation error to 
    ! ensure accuracy and adjust stepsize
    !
    ! input: 
    ! :NTCSPECxNTCISO-size vectors of variables IVIO and its derivatives IDI at 
    ! the starting value of the independent variable t
    ! htry: the stepsize to be attempted htry
    ! eps: required accuracy eps
    ! ESC: vector against which the error is scaled
    !
    ! output: 
    ! :IVIO and t are replaced by their new values
    ! hdid: stepsize that was actually accomplished
    ! hnext: estimated next stepsize
  
      INTEGER             :: i, j
      REAL(dp)            :: errmax, h, htemp, tnew

      REAL(dp)            :: IVT(NTCSPEC,NTCISO)      ! temp
      REAL(dp)            :: IER(NTCSPEC,NTCISO)      ! error
      
      REAL(dp), PARAMETER :: SAFETY = 0.9_dp, &
                              PGROW = -0.2_dp, &
                             PSHRNK = -0.25_dp, &
                             ERRCON = (5.0_dp/SAFETY)**(1.0_dp/PGROW)  ! 1.89E-4_dp !
    
      ! The value ERRCON equals , see use below.
    
      h = htry           ! setting stepsize to the initial trial value
    
   77 CALL cashkarp(IVIO,IDI,t,h,IVT,IER)      ! taking a step
  
      errmax = 0.0_dp                          ! evaluating accuracy
      DO j = 1, NTCISO 
        DO i = 1, NTCSPEC 
          errmax = MAX(errmax,DABS(IER(i,j)/ESC(i,j)))
    ENDDO
      ENDDO
    
      errmax = errmax/eps                      ! scaling relative to required tolerance
    
      IF (errmax .GT. 1.0_dp) THEN             ! truncation error is too large, reduce stepsize
    
        htemp = SAFETY * h * (errmax**PSHRNK)
        h = SIGN(MAX(DABS(htemp),0.1_dp*DABS(h)),h)     ! Not more than a factor of 10
        tnew = t + h
    
        IF (tnew .EQ. t) pause 'stepper: stepsize underflow'
        GOTO 77                                ! For another try.
  
      ELSE                                     ! Step succeeded. Computing the size of next step.
  
        IF (errmax .GT. ERRCON) THEN
          hnext = SAFETY * h * (errmax**PGROW)
        ELSE                                   ! No more than a factor of 5 increase.
          hnext = 5.0_dp * h
        ENDIF
    
        hdid = h
        t = t + h
    
        IVIO = IVT                             ! IVT() is returned from cashkarp
    
        RETURN
  
      ENDIF
    
    END SUBROUTINE stepper
  
  ! ---------------------------------------------------------------------------

    SUBROUTINE rkckintegrate(IVIO,t1,t2,eps,h1,hmin,nok,nbad)
    
      REAL(dp), INTENT(INOUT) :: IVIO(NTCSPEC,NTCISO)  ! in-out values
      REAL(dp), INTENT(IN)    :: t1, t2, eps, h1, hmin
  
      INTEGER, INTENT(OUT)    :: nok, nbad
  
      REAL(dp)                :: IVT(NTCSPEC,NTCISO)      ! temp vars
      REAL(dp)                :: IDT(NTCSPEC,NTCISO)      ! temp der
      REAL(dp)                :: IER(NTCSPEC,NTCISO)      ! error
      REAL(dp)                :: ESC(NTCSPEC,NTCISO)      ! error scale
  
      INTEGER, PARAMETER :: MAXSTP = 10000, &
                            ATINY =  1.e-30 ! TINY(dp) !
  
    ! Runge-Kutta driver with adaptive stepsize control
    ! 
    ! input:
    ! integrating the starting values IVIO()
    ! from t1 to t2 with accuracy eps
    ! storing intermediate results in the common block /path/.
    ! h1 should be set as a guessed first stepsize
    ! hmin as the minimum allowed stepsize (can be zero). 
    !
    ! output:
    ! nok and nbad are the number of good and bad (but retried and fixed) steps taken
    ! and IVIO is replaced by values at the end of the integration interval
    
      INTEGER                 :: i, j, nstp, nact
      REAL(dp)                :: t, h, hdid, hnext
    
      t = t1
      h = DSIGN(h1,t2-t1)
      nok = 0
      nbad = 0
    
      IVT = IVIO                               ! IVT - operational vector

      DO nstp = 1, MAXSTP                      ! take at most MAXSTP steps
  
        CALL iderivs(t,IVT,IDT)
      
        ! scaling (used for monitoring accuracy)
        ! can be modifed if there is a need

        ESC(:,:) = DABS(IVT(:,:)) + DABS(h*IDT(:,:)) + ATINY
    
        ! if stepsize can overshoot, decreasing
        IF ((t+h-t2)*(t+h-t1) .GT. 0.0_dp) h = t2 - t  
        
        CALL stepper(IVT,IDT,t,h,eps,ESC,hdid,hnext)
  
        IF (hdid .EQ. h) THEN
          nok = nok+1
        ELSE
          nbad = nbad+1
        ENDIF
    
        IF ((t-t2)*(t2-t1) .GE. 0.) THEN      ! done?
          
          IVIO = IVT                          ! output values
          RETURN                              ! normal exit
  
        ENDIF
  
        IF (DABS(hnext) .LT. hmin) pause 'rkckintegrate: stepsize smaller than minimum'
        h = hnext
      
      ENDDO       ! nstp cycle
  
      pause 'rkckintegrate: too many steps'
  
      RETURN
  
    END SUBROUTINE rkckintegrate

! <<<<< CASH-KARP RK integration scheme <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#endif

  END SUBROUTINE tag_IC_integrate



! -----------------------------------------------------------------------------

  SUBROUTINE tag_IC_calctotals(C)

    IMPLICIT NONE

    ! I/O
    REAL(dp), INTENT(IN) :: C(:)

    INTEGER  :: i

  ! minor isotopologues contribute with 1 rare atom
    TC(2:NTCISO) = SUM(ISOC(:,2:NTCISO))
    
  ! abundant atoms quantity is the rest
    TC(1) = SUM(SUM(ISOC(:,:),DIM=2)*QTCATOM(:)) - SUM(TC(2:NTCISO))

  ! total C atoms quantity from the regular mechanism
    TC_R = SUM(C(RTCIND(:))*QTCATOM(:))

!***    T13C = SUM(I13C(:))
!    T12C = SUM(I12C(1:NTCSPEC)*QTCATOM(:))

#ifdef DEBUG
    print *,'tag_IC_calctotals: passed'
#endif 

  END SUBROUTINE tag_IC_calctotals



! -----------------------------------------------------------------------------
  
! correction of total isotopologues budget to "regular" species budget  

  SUBROUTINE tag_IC_correct2reg(C)

    USE messy_mecca_kpp, ONLY: SPC_NAMES

    IMPLICIT NONE

    ! I/O
    REAL(dp), INTENT(IN)  :: C(:)

    INTEGER        :: i
    CHARACTER(100) :: specs
    REAL(dp) :: tot
    
    specs = ""
    tag_IC_NCOR2R = 0

    DO i = 1, NTCSPEC
      tot = ( I12C(i) + I13C(i) )
      IF (tot .EQ. 0.0_dp) THEN
        specs = TRIM(specs)//" "//TRIM(SPC_NAMES(RTCIND(i)))
        I12C(i) = 0.0_dp
        I13C(i) = 0.0_dp
      ELSE
#ifdef C2R_FILTER
        IF ( (tot/C(RTCIND(i))) .GT. THRES_C2R) THEN
#endif
          I12C(i) = ( C(RTCIND(i)) * I12C(i) ) / tot
          I13C(i) = ( C(RTCIND(i)) * I13C(i) ) / tot
          tag_IC_NCOR2R = tag_IC_NCOR2R + 1
#ifdef C2R_FILTER
        ENDIF
#endif 
      ENDIF

    ENDDO

  ! getting a fraction of corrected specs
    tag_IC_NCOR2R = tag_IC_NCOR2R / NTCSPEC

#ifdef DEBUG
    IF (LEN(TRIM(specs)) .GT. 0) THEN
      WRITE(*,'(A,A)') 'tag_IC_correct2reg: '//&
              'cannot correct isotopic C species due to zero-budget: ', &
               specs
    ELSE
      print *,'tag_IC_correct2reg: working'
    ENDIF
#endif 

  END SUBROUTINE tag_IC_correct2reg



! -----------------------------------------------------------------------------
  
! correction of "regular" species budget to the total isotopologues budget

  SUBROUTINE tag_IC_correct2iso(C)

    IMPLICIT NONE

    ! I/O
    REAL(dp), INTENT(INOUT)  :: C(:)

    INTEGER  :: i

      C(RTCIND(:)) = I12C(:) + I13C(:)

#ifdef DEBUG
    print *,'tag_IC_correct2iso: working'
#endif 

  END SUBROUTINE tag_IC_correct2iso



! - some cfg cheks ------------------------------------------------------------

#ifndef I_LINMAX
#ifndef I_SIMEULER
#ifndef I_CASHKARP
 FATAL: no integration method choosed
#endif
#endif
#endif

! ---------------------------------------------------------------------------

END MODULE messy_mecca_tag_IC

! ***************************************************************************

