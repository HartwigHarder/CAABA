! ==============================================================================
! {%CMODEL}_{%TAG}
! generated: {%TIMEDATE}
!
! this module is generated by imtag utility
!
! {%ATOM} isotopes tagging configuration: kinetics
! level: smcl
!
! {$TAG_INFO} ! this is a template for isotopes configuration
!
! [Gromov, MPIC, 2007-2008]
! ==============================================================================

! - general tagging parameters (as conditional defines) ------------------------

#include "{%CMODEL}_tag_parameters.inc"

! - configuration parameters ---------------------------------------------------

! {$CONF_PARAM}

! - integration scheme ---------------------------------------------------------

! define in cfg with INT_LINMAX, INT_SIMEULER, INT_CASHKARP params

! -----------------------------------------------------------------------------

MODULE {%CMODEL}_{%TAG}

  USE messy_mecca_kpp ! dp, nreact, nspec, ind_*, ...

#ifdef INTERFLOW
! in case of inter-configuration molecules flow calculation (default) 
! using flow and its direction variables from {%CMODEL}_tag

  USE {%CMODEL}_tag_common
#endif


  IMPLICIT NONE

! here constants and tracers are to be defined
! {$TRAC_DECL} [%ind_#%] <-- boxmodel syntax  (%{%TAG}_#%) <-- isotracers syntax

! index used for substitution of isotopic fraction of total {%ATOM}
  INTEGER, PARAMETER :: ind_tT{%ATOM} = {%NTSPEC}+1

! -----------------------------------------------------------------------------

#ifndef INTERFLOW
! {%ATOM} atoms flow control and directions indices
  INTEGER, PARAMETER :: NFL{%ATOM}DIR = {%QCFLDIR}
  REAL(dp)           :: flow(NFL{%ATOM}DIR)
  INTEGER, PARAMETER, PRIVATE :: &
! {$FLOW_DIRS} [% # = $%]
#else
! flow() is imported from {%CMODEL}_tag_common
#endif

! -----------------------------------------------------------------------------

! concentrations of isotopologues
  REAL(dp)           :: ISO{%ATOM}({%NTSPEC},{%NISO})

  REAL(dp)           :: T{%ATOM}({%NISO})

! total {%ATOM} (atoms) of the regular composition
  REAL(dp)           :: T{%ATOM}_R

->>- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {>ATOM:C}
! 12C 13C tagged species arrays
  REAL(dp)           :: I12C({%NTSPEC})
  REAL(dp)           :: I13C({%NTSPEC})
    EQUIVALENCE( I12C(1),ISO{%ATOM}(1,1) )
    EQUIVALENCE( I13C(1),ISO{%ATOM}(1,2) )

! totals (atoms)
  REAL(dp)           :: T12C, T13C
    EQUIVALENCE( T12C, T{%ATOM}(1) )
    EQUIVALENCE( T13C, T{%ATOM}(2) )
-<<- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {<ATOM:C}
->>- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {>ATOM:O}
! 16O 17O 18O tagged species arrays
  REAL(dp)           :: I16O({%NTSPEC})
  REAL(dp)           :: I17O({%NTSPEC})
  REAL(dp)           :: I18O({%NTSPEC})
    EQUIVALENCE( I16O(1),ISO{%ATOM}(1,1) )
    EQUIVALENCE( I17O(1),ISO{%ATOM}(1,2) )
    EQUIVALENCE( I18O(1),ISO{%ATOM}(1,3) )

! totals (atoms)
  REAL(dp)           :: T16O, T17O, T18O
    EQUIVALENCE( T16O, T{%ATOM}(1) )
    EQUIVALENCE( T17O, T{%ATOM}(2) )
    EQUIVALENCE( T18O, T{%ATOM}(3) )
-<<- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {<ATOM:O}

! fractions (operative), +1 for T{%ATOM}
->>- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {>ATOM:C}
  REAL(dp)           :: F12C({%NTSPEC}+1), &
                        F13C({%NTSPEC}+1)
-<<- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {<ATOM:C}
->>- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {>ATOM:O}
  REAL(dp)           :: F16O({%NTSPEC}+1), &
                        F17O({%NTSPEC}+1), &
                        F18O({%NTSPEC}+1)
-<<- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {<ATOM:O}

! -----------------------------------------------------------------------------

! runtime control parameters

! treshold value: below it species stops to sink to the others (but can receive)
!                                         x * mean cair
  REAL(dp), PARAMETER :: THRES = 1.0E-40_dp * 2.5047E+19_dp

! last "process" run steps count, requested steps count
  INTEGER             :: {%TAG}_NSTEP, {%TAG}_NSTEP_REQ

! # of "rejected" species (under threshold)
  INTEGER             :: {%TAG}_NREJCT
  
! # of potential error due to PTs vs. A difference over 1 order of magnitude
  INTEGER             :: {%TAG}_PEPTAD

! fraction of "corrected to regular" species (diagnostic) & filter threshold
  REAL(dp)            :: {%TAG}_NCOR2R
  REAL(dp), PARAMETER :: THRES_C2R = 1.0E-3_dp ! (max. ratio tag/reg allowed)

! -----------------------------------------------------------------------------

  PUBLIC

  PRIVATE zerodiv

  PRIVATE THRES, THRES_C2R

#ifndef INTERFLOW
  PRIVATE flow
#endif

  PUBLIC {%TAG}_update_kie
  PUBLIC {%TAG}_flow_calc
  PUBLIC {%TAG}_integrate
  PUBLIC {%TAG}_calctotals
  PUBLIC {%TAG}_correct2reg
  PUBLIC {%TAG}_correct2iso

! =============================================================================

CONTAINS

! -----------------------------------------------------------------------------

  ELEMENTAL REAL(dp) FUNCTION zerodiv(what,by)
    ! safe division which gives zero when division by zero is performed
    REAL(dp), INTENT(IN) :: what, by   ! operands
    IF (by .EQ. 0.0_dp) THEN
      zerodiv = 0.0_dp
    ELSE
      zerodiv = what/by
    ENDIF
  END FUNCTION zerodiv



! -----------------------------------------------------------------------------

  SUBROUTINE {%TAG}_update_kie(C, press, cair, temp)

    IMPLICIT NONE

    ! I/O
    REAL(dp), INTENT(IN) :: C(:)
    REAL(dp), INTENT(IN) :: press
    REAL(dp), INTENT(IN) :: cair
    REAL(dp), INTENT(IN) :: temp

  ! ===== KIE preparation section (coeff. update, etc.) =======================

! {$KIE_PROC}

  ! ===== calculation of KIE-correction for reac/isot =========================

! {$KIE_CALC}  [%C(ind_PT#)%]    <-- boxmodel syntax
  
  END SUBROUTINE {%TAG}_update_kie



! -----------------------------------------------------------------------------

  SUBROUTINE {%TAG}_flow_calc(C, TSL)
    
  ! this subroutine calculates flow of {%ATOM}-containig molecules
  ! from one tagged species to another, plus sinks; from PTs
    
    IMPLICIT NONE

    ! I/O
    REAL(dp), INTENT(IN)  :: C(:), TSL

#ifndef INTERFLOW
->>- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {>CASE:REMARK}
! remark on use of FLOW_CALC directive:
! in [% %] braces: an expression gives the reaction production (molec./int.step)
! # - reaction abbreviature, $ - internal tagging no., refer to TRPT{%ATOM}IND()
!
! {$FLOW_CALC}  [%PT-value expression (# or $)%]
! 
! ex.: 
! {$FLOW_CALC}  [%C(ind_PT#)%]
! {$FLOW_CALC}  [A(TRPT{%ATOM}IND($,2))%]
-<<- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {<CASE:REMARK}
! {$FLOW_CALC}  [%C(ind_PT#)%]    <-- boxmodel optim.
#endif

  END SUBROUTINE {%TAG}_flow_calc

! -----------------------------------------------------------------------------

! main subroutine of isotopic exchange calculation

  SUBROUTINE {%TAG}_integrate(TSL, nstep, C, press, cair, temp)

! turned off so far due to incompatibility with CAABA variables management
!   USE messy_mecca_kpp, ONLY: A, SPC_NAMES, EQN_TAGS

    IMPLICIT NONE

    ! I/O
    REAL(dp), INTENT(IN) :: C(:)
    REAL(dp), INTENT(IN) :: press
    REAL(dp), INTENT(IN) :: cair
    REAL(dp), INTENT(IN) :: temp

    INTRINSIC SUM

  ! TSL = times_step_len value    
    REAL(dp), INTENT(IN) :: TSL
  
  ! number of steps to take ( = nsteps from integrator? )
    INTEGER, INTENT(IN)  :: nstep

    REAL(dp) :: tot

#ifdef INT_LINMAX
    INTEGER  :: n, s, k, nok, nbad
  ! jacobians
    REAL(dp) :: J({%NTSPEC},{%NTSPEC},{%NISO})
  ! weights
    REAL(dp) :: Z({%NTSPEC})
  ! fractions
    REAL(dp) :: F({%NTSPEC},{%NISO})
  ! atomic content
    REAL(dp) :: IA({%NTSPEC}), &
                IR({%NTSPEC},2:{%NISO}), &
                IAR({%NTSPEC},2:{%NISO})
    REAL(dp) :: delta, comp
    INTEGER  :: steps
#endif

#ifdef INT_SIMEULER
    INTEGER  :: n, s, nok, nbad
    REAL(dp) :: part, delta, done
    LOGICAL  :: reject, reject_last
    REAL(dp) :: ISAVE({%NTSPEC},{%NISO}), IDER({%NTSPEC},{%NISO})
    REAL(dp), PARAMETER :: CLOSE_FAC = 0.2_dp, FAR_FAC = 2.0_dp
#endif

#ifdef INT_CASHKARP
    INTEGER  :: n, nok, nbad
#endif

  ! ===========================================================================

  ! some diagnostic checks
  ! turned off so far due to incompatibility with CAABA variables management

  ! checking A() and PTs correspondence
!   {%TAG}_PEPTAD = 0
!   DO n = 1, NT{%ATOM}REAC                                  v C is already scaled to TSL now!
!     IF ( ( A(TRPT{%ATOM}IND(n,2)) / (C(TRPT{%ATOM}IND(n,1))/TSL) ) .LT.  0.1_dp ) THEN
#ifdef DEBUG
!       print *,'{%TAG}_process: A << PT: ',TRIM(EQN_TAGS(TRPT{%ATOM}IND(n,1)))
#endif
!       {%TAG}_PEPTAD = {%TAG}_PEPTAD + 1
!     ENDIF
!     IF ( ( A(TRPT{%ATOM}IND(n,2)) / (C(TRPT{%ATOM}IND(n,1))/TSL) ) .GT. 10.0_dp ) THEN
#ifdef DEBUG
!       print *,'{%TAG}_process: A >> PT: ',TRIM(EQN_TAGS(TRPT{%ATOM}IND(n,1)))
#endif
!       {%TAG}_PEPTAD = {%TAG}_PEPTAD + 1
!     ENDIF
!   ENDDO

  ! ----- prepairing flow (if not INTERFLOW) ----------------------------------

#ifndef INTERFLOW
  ! calculate {%ATOM} molecules flow through PTs (or A)
    CALL {%TAG}_flow_calc(C, TSL)
#endif
    
  ! warning: due to weighting, calculate KIE correcion after flow_calc

  ! prepairing KIE correction values
    CALL {%TAG}_update_kie(C, press, cair, temp)

#ifdef INT_LINMAX
! >>>>> LINEAR-MATRIX integration scheme >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  ! ----- setting up jacobians -----

  ! though weights are no longer used -- subject to remove!
    CALL prepare_Z(0,1.0_dp)                  ! prepare weights:    type 0 1 2 3 4 5
    CALL prepare_J(.FALSE.)                   ! prepare "major jacobian"

  ! filling the minor matrices
    DO k = 2, {%NISO}
      J(:,:,k) = J(:,:,1)
    ENDDO

  ! ----- accounting KIE -----

  ! prepairing "minor jacobian(s)"
->>- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {>CASE:REMARK}
! remark on JAC_KIE usage:
!
! [% %] - jacobian calculation expression for # - sinking, $ - receiving indices
! ~ - jacobian "upper" part, i.e. sum of flow(#_$)-kie_correction for current # and $
!
! {$JAC_KIE I13C} [%    J(ind_t$, ind_t#) = zerodiv(~, Z(ind_t#))%]
-<<- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {<CASE:REMARK}
->>- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {>ATOM:C}
! {$JAC_KIE I12C} [%    J({%TAG}_$, {%TAG}_#, 1) = zerodiv(~, Z({%TAG}_#))%]
! {$JAC_KIE I13C} [%    J({%TAG}_$, {%TAG}_#, 2) = zerodiv(~, Z({%TAG}_#))%]
->>- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {<ATOM:C}
->>- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {>ATOM:O}
! {$JAC_KIE I16O} [%    J({%TAG}_$, {%TAG}_#, 1) = zerodiv(~, Z({%TAG}_#))%]
! {$JAC_KIE I17O} [%    J({%TAG}_$, {%TAG}_#, 2) = zerodiv(~, Z({%TAG}_#))%]
! {$JAC_KIE I18O} [%    J({%TAG}_$, {%TAG}_#, 3) = zerodiv(~, Z({%TAG}_#))%]
->>- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {<ATOM:O}
->>- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {>!KIE:}
  ! no KIE specified in this configuration
->>- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {<!KIE:}

  ! ----- stepping -----

  ! assessing values from the "major jacobian"

    delta = 0.0_dp
    DO n = 1, NTCSPEC
!     comp = MAXVAL(J(n,:,1), MASK=(J(n,:,1) .GT. 0.0_dp)) / &
!            MINVAL(J(n,:,1), MASK=(J(n,:,1) .GT. 0.0_dp))
      comp = MAXVAL(J(n,:,1), MASK=(J(n,:,1) .GT. 0.0_dp)) / &
             MINVAL(J(n,:,1), MASK=(J(n,:,1) .GT. 0.0_dp)) / C(TRPTIND(n))
      IF (comp .GT. delta) delta = comp
    ENDDO

  ! choosing the number of steps

    steps = INT(2*1.0E5 * delta**2.71)
!    steps = INT(5.0E3 * done)
!    steps = 100000

    IF (steps .LT. 10) steps = 10
    IF (steps .GT. 10000) steps = 10000
    
    delta = TSL / steps

  ! ----- integration loop -----

    {%TAG}_NREJCT = 0

    DO s = 1, steps 

    ! getting the fractions of isotopologues
      DO n = 1, {%NSPEC}
        comp = SUM(ISO{%A}(n,:))              ! gettting total
#ifdef OPT_LOW_FILTER
        IF (comp .LT. THRES) THEN
#else
        IF (comp .EQ. 0.0_dp) THEN
#endif
          F(n,:) = 0.0_dp
          tag_IC_NREJCT = tag_IC_NREJCT + 1
        ELSE
          F(n,:) = (ISOC(n,:) / comp)
        ENDIF
      ENDDO

#ifndef ISO
    ! advancing solution: for non-isotopic case
      DO k = 1, {%NISO}
        ISOC(:,k)  = ISOC(:,k) + delta * MATMUL(J(:,:,k),F(:,k))
      ENDDO
#else
    ! scaling tracers: molecules to atoms
    ! abundant
      IA(:) = ISO{%A}(:,1)
      DO k = 2, {%NISO}  
      ! rare
        IR(:,k) = ISO{%A}(:,k) / QT{%A}ATOM(:)
      ! abundant in rare
        IAR(:,k) = ISO{%A}(:,k) - IR(:,k)
      ENDDO

    ! advancing solution: isotopic transfer
      IA(:) = IA(:) + delta * MATMUL(J(:,:,1),F(:,1))
      DO k = 2, {%NISO}
        IR(:,k)  = IR(:,k)  + delta * MATMUL(J(:,:,k),F(:,k))
        IAR(:,k) = IAR(:,k) + delta * MATMUL(J(:,:,k),F(:,k))
      ENDDO

    ! scaling tracers: atoms to molecules
    ! abundant  
      ISO{%A}(:,1) = IA(:) + SUM(IAR(:,:),DIM=2) - SUM(IR(:,:),DIM=2) * (QT{%A}ATOM(:)-1)
    ! rare
      DO k = 2, {%NISO}  
        ISO{%A}(:,k) = IR(:,k) * QT{%A}ATOM(:)
      ENDDO
#endif

    ! filtering negative concentrations 
      DO n = 1, NTCSPEC
        DO k = 1, NTCISO    
          IF (ISOC(n,k) .LT. 0.0_dp) THEN
          print *,'tag_IC_integrate: ',TRIM(SPC_NAMES(RTCIND(n))),', class #',k,&
	          ' is negative = ',ISOC(n,k)
          ISOC(n,k) = 0.0_dp
          ENDIF
	ENDDO
      ENDDO
      
    ENDDO

  ! ----- finalizing -----

!    CALL {%TAG}_calcdeltas

!    print *,' DD13,DC = ',D13C(ind_tCH3O2)-(C(ind_I13CH3O2)/C(ind_I12CH3O2)/VPDB_13C-1.0_dp)*1000.0_dp, &
!            ' ',I12C(ind_tCH3O2)+I13C(ind_tCH3O2)-C(ind_CH3O2)

    {%TAG}_NSTEP = steps
    {%TAG}_NREJCT = {%TAG}_NREJCT / {%TAG}_NSTEP

#ifdef KIE
    ! necessary for KIE
    CALL {%TAG}_correct2reg(C)
#endif
    
! <<<<< LINEAR-MATRIX integration scheme <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#endif


#ifdef INT_SIMEULER
! {$INCLUDE} <imtag_i=simeuler.inc>
#endif

#ifdef INT_CASHKARP
! >>>>> CASH-KARP RK integration scheme >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                                              
  ! calling integrator                                                        
    CALL rkckintegrate(ISO{%ATOM}, &                                          
                       0.0_dp, 1.0_dp, 1.0E-7_dp, &                           
                       1.0_dp/DBLE(nstep), 0.0_dp, &                          
                       nok, nbad)                                             
                                                                              
  ! run-control parameters                                                    
    {%TAG}_NSTEP = nok + nbad      ! # of integration steps made              
                                                                              
    ! # of rejected species (approx.: C-K takes derivatives 6 times per step) 
    IF ( {%TAG}_NSTEP /= 0 ) THEN                                             
      {%TAG}_NREJCT = {%TAG}_NREJCT / ( {%TAG}_NSTEP * 6 )                    
    ELSE                                                                      
      {%TAG}_NREJCT = 0                                                       
    ENDIF                                                                     
                                                                              
! <<<<< CASH-KARP RK integration scheme <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#endif

  ! CALL {%TAG}_correct2reg(C)
  ! CALL {%TAG}_calctotals(C)
  ! CALL {%TAG}_calcdeltas

  ! run-control parameters                                                    
    {%TAG}_NSTEP_REQ = nstep       ! # of requested steps                     

#ifdef DEBUG
    print *,'{%TAG}_integrate: passed, req: ',{%TAG}_NSTEP_REQ, &
                                    ', steps: ', {%TAG}_NSTEP, &
                                    ', rej: ', {%TAG}_NREJCT
#endif 

  CONTAINS

  ! ----------------------------------------------------------------------------

->>- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {>CASE:REMARK}
! remark on use of the $DERIVS directive:
!
! {$DERIVS_ImA} [%dest(#)%] = (%sum(#)%) + {%delta%} * <%frac(#)%> last
!
! where
! A - atom
! m - mass
! # - replaced with the species indices (ind_tXXX)
! and funny braces containing expressions with:
! [% %] - name of the destination variable (left drom =)
! (% %) - name of the variable to sum with (1st right from =)
! <% %> - name of the corresponding fraction variable (multiplied by flow())
! {% %} - name of the step variable (multiplied by sum of all flows()
! "!" character in funny braces cancels usage of sum and step variables
! last - means that this last isotopologue derivative is calculated as 
!        difference of already known and total derivative of the species (flow)
!
! examples:
! [%I12C(#)%]         = (%I12C(#)%)         + {%H%} * <%F12C(#)%>         or
! [%ISOC(#,1)%]       = (%ISOC(#,1)%)       + {%H%} * <%FRAC(#,1)%>       or                                         
! [%IC(#+{%NTSPEC})%] = (%IC(#+{%NTSPEC})%) + {%H(1-#)%} * <%FC(#+{%NTSPEC})%> 
! etc.
-<<- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {<CASE:REMARK}

    SUBROUTINE iderivs(t,IVI,IDO)

    ! Subroutine iderivs returns isotopologues derivatives in IDO(), using 
    ! the starting values from IVI(), PTs and flow() at the moment t (which
    ! actually is not used)

      IMPLICIT NONE

      INTRINSIC SUM
      
      REAL(dp), INTENT(IN)  :: t 
      REAL(dp), INTENT(IN)  :: IVI({%NTSPEC},{%NISO})
      REAL(dp), INTENT(OUT) :: IDO({%NTSPEC},{%NISO})
  
      REAL(dp)              :: tot
      INTEGER               :: i

      ! getting the fractions of isotopologues
        DO i = 1, {%NTSPEC}
->>- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {>ATOM:C}
          tot = SUM(IVI(i,:))    ! summing spec 
-<<- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {<ATOM:C}
          IF (tot .LT. THRES) THEN
!         IF (tot .NE. 0.0_dp) THEN
->>- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {>ATOM:C}
            F12C(i) = 0.0_dp; F13C(i) = 0.0_dp
-<<- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {<ATOM:C}
->>- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {>ATOM:O}
            F16O(i) = 0.0_dp; F17O(i) = 0.0_dp; F18O(i) = 0.0_dp
-<<- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {<ATOM:O}
            {%TAG}_NREJCT = {%TAG}_NREJCT + 1
          ELSE
->>- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {>ATOM:C}
            F12C(i) = (IVI(i,1) / tot)
            F13C(i) = (IVI(i,2) / tot)
-<<- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {<ATOM:C}
->>- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {>ATOM:O}
            F16O(i) = (IVI(i,1) / tot)
            F17O(i) = (IVI(i,2) / tot)
            F18O(i) = (IVI(i,3) / tot)
-<<- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {<ATOM:O}
          ENDIF
        ENDDO

->>- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {>ATOM:C}
      ! calculating 12C 13C isotopologues derivatives

! {$DERIVS_I12C} [%IDO({%TAG}_#,1)%] = (%!%) + {%!%} * <%F12C({%TAG}_#)%> 
                                         
! {$DERIVS_I13C} [%IDO({%TAG}_#,2)%] = (%!%) + {%!%} * <%F13C({%TAG}_#)%> last
-<<- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {<ATOM:C}
->>- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {>ATOM:O}
      ! calculating 16O 17O 18O isotopologues derivatives

! {$DERIVS_I16O} [%IDO({%TAG}_#,1)%] = (%!%) + {%!%} * <%F16O({%TAG}_#)%> 
                                         
! {$DERIVS_I17O} [%IDO({%TAG}_#,2)%] = (%!%) + {%!%} * <%F17O({%TAG}_#)%> 

! {$DERIVS_I18O} [%IDO({%TAG}_#,3)%] = (%!%) + {%!%} * <%F18O({%TAG}_#)%> last
-<<- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {<ATOM:O}

    END SUBROUTINE iderivs

  ! ----------------------------------------------------------------------------

#ifdef INT_LINMAX
! >>>>> LINEAR-MATRIX integration scheme >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

    SUBROUTINE prepare_Z(akind,stepping)

      IMPLICIT NONE
      
      INTRINSIC SUM

      INTEGER, INTENT(in) :: akind           ! "weighting": fractions of current & already calculated budgets
      REAL(dp), INTENT(in) :: stepping       ! # of steps

      ! coefficients are chosen empirically, need to understand
      SELECT CASE (akind)
      CASE (0)
        Z(:) = 1.0_dp
      CASE (1)
        Z(:) = SUM(ISO{%A}(:,:),DIM=2)
      CASE (2)
        Z(:) = 0.75_dp * SUM(ISO{%A}(:,:),DIM=2) + 0.25_dp * C({%RTIND}(:))
      CASE DEFAULT     ! or 3
        Z(:) = 0.5_dp * (SUM(ISO{%A}(:,:),DIM=2) + C({%RTIND}(:)))
      CASE (4)
        Z(:) = 0.25_dp * SUM(ISO{%A}(:,:),DIM=2) + 0.75_dp * C({%RTIND}(:))
      CASE (5)
        Z(:) = C({%RTIND}(:))
      END SELECT
      
      Z(:) = Z(:) * stepping

    END SUBROUTINE prepare_Z
    
  ! ---------------------------------------------------------------------------

    SUBROUTINE prepare_J(do_inv)

      IMPLICIT NONE
      
      LOGICAL, INTENT(in) :: do_inv          ! do a preparation for a further J inversion? 
                                             !   i.e. J = (I - J/stepping)    -> ^(-1)
      INTEGER :: n

      J(:,:,1) = 0.0_dp

      ! weights (Z) should be defined by this moment

->>- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {>CASE:REMARK}
! remark on JAC_CALC usage:
!
! [% %] - jacobian calculation expression for # - sinking, $ - receiving indices
! ~ - jacobian "upper" part, i.e. sum of flow(#_$) for current # and $
!
! {$JAC_CALC} [%      J(ind_t$, ind_t#) = zerodiv(~, Z(ind_t#))%]
-<<- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {<CASE:REMARK}
! {$JAC_CALC} [%      J({%TAG}_$,{%TAG}_#,1) = zerodiv(~,Z({%TAG}_#))%]
      
      IF (do_inv) THEN          ! (do_inv .EQ. .TRUE.) removed due to g95 problems
      ! inverting coeffs
        J(:,:,1) = -J(:,:,1)    
      ! adding E to M
        DO n = 1, {%NTSPEC}
          J(n,n,1) = J(n,n,1) + 1.0_dp
        ENDDO

      ENDIF

    END SUBROUTINE prepare_J

! {$INCLUDE} <imtag_i=linealg.inc>

! <<<<< LINEAR-MATRIX integration scheme <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#endif
    
#ifdef INT_CASHKARP
! {$INCLUDE} <imtag_i=cashkarp_rk.inc>
#endif

  END SUBROUTINE {%TAG}_integrate



! -----------------------------------------------------------------------------

  SUBROUTINE {%TAG}_calctotals(C)

    IMPLICIT NONE

    ! I/O
    REAL(dp), INTENT(IN) :: C(:)

    INTEGER  :: i

  ! minor isotopologues contribute with 1 rare atom
    T{%ATOM}(2:{%NISO}) = SUM(ISO{%ATOM}(:,2:{%NISO}))
    
  ! abundant atoms quantity is the rest
    T{%ATOM}(1) = SUM(SUM(ISO{%ATOM}(:,:),DIM=2)*QT{%ATOM}ATOM(:)) - SUM(T{%ATOM}(2:{%NISO}))

  ! total {%ATOM} atoms quantity from the regular mechanism
    T{%ATOM}_R = SUM(C({%RTIND}(:))*QT{%ATOM}ATOM(:))

->>- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {>ATOM:C}
!***    T13C = SUM(I13C(:))
!    T12C = SUM(I12C(1:{%NTSPEC})*QT{%ATOM}ATOM(:))
-<<- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {<ATOM:C}
->>- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {>ATOM:O}
!    T16O = SUM(I16O(1:{%NTSPEC})*QT{%ATOM}ATOM(:))
!    T17O = SUM(I17O(1:{%NTSPEC})*QT{%ATOM}ATOM(:))
!    T18O = SUM(I18O(1:{%NTSPEC})*QT{%ATOM}ATOM(:))
-<<- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {<ATOM:O}

#ifdef DEBUG
    print *,'{%TAG}_calctotals: passed'
#endif 

  END SUBROUTINE {%TAG}_calctotals



! -----------------------------------------------------------------------------
  
! correction of total isotopologues budget to "regular" species budget  

  SUBROUTINE {%TAG}_correct2reg(C)

    USE messy_mecca_kpp, ONLY: SPC_NAMES

    IMPLICIT NONE

    ! I/O
    REAL(dp), INTENT(IN)  :: C(:)

    INTEGER        :: i
    CHARACTER(100) :: specs
    REAL(dp) :: tot
    
    specs = ""
    {%TAG}_NCOR2R = 0

->>- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {>ATOM:C}
    DO i = 1, {%NTSPEC}
      tot = ( I12C(i) + I13C(i) )
      IF (tot .EQ. 0.0_dp) THEN
        specs = TRIM(specs)//" "//TRIM(SPC_NAMES({%RTIND}(i)))
        I12C(i) = 0.0_dp
        I13C(i) = 0.0_dp
      ELSE
#ifdef OPT_C2R_FILTER
        IF ( (tot/C({%RTIND}(i))) .GT. THRES_C2R) THEN
#endif
          I12C(i) = ( C({%RTIND}(i)) * I12C(i) ) / tot
          I13C(i) = ( C({%RTIND}(i)) * I13C(i) ) / tot
          {%TAG}_NCOR2R = {%TAG}_NCOR2R + 1
#ifdef OPT_C2R_FILTER
        ENDIF
#endif 
      ENDIF

    ENDDO
-<<- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {<ATOM:C}
->>- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {>ATOM:O}
    DO i = 1, {%NTSPEC}
      tot = ( I16O(i) + I17O(i) + I18O(i) )
      IF (tot .EQ. 0.0_dp) THEN
        specs = TRIM(specs)//" "//TRIM(SPC_NAMES({%RTIND}(i)))
        I16O(i) = 0.0_dp
        I17O(i) = 0.0_dp
        I18O(i) = 0.0_dp
      ELSE
#ifdef OPT_C2R_FILTER
        IF ( (tot/C({%RTIND}(i))) .GT. THRES_C2R) THEN
#endif
          I16O(i) = ( C({%RTIND}(i)) * I16O(i) ) / tot
          I17O(i) = ( C({%RTIND}(i)) * I17O(i) ) / tot
          I18O(i) = ( C({%RTIND}(i)) * I18O(i) ) / tot
#ifdef OPT_C2R_FILTER
        ENDIF
#endif 
      ENDIF
    ENDDO
-<<- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {<ATOM:O}

  ! getting a fraction of corrected specs
    {%TAG}_NCOR2R = {%TAG}_NCOR2R / {%NTSPEC}

#ifdef DEBUG
    IF (LEN(TRIM(specs)) .GT. 0) THEN
      WRITE(*,'(A,A)') '{%TAG}_correct2reg: '//&
              'cannot correct isotopic {%ATOM} species due to zero-budget: ', &
               specs
    ELSE
      print *,'{%TAG}_correct2reg: working'
    ENDIF
#endif 

  END SUBROUTINE {%TAG}_correct2reg



! -----------------------------------------------------------------------------
  
! correction of "regular" species budget to the total isotopologues budget

  SUBROUTINE {%TAG}_correct2iso(C)

    IMPLICIT NONE

    ! I/O
    REAL(dp), INTENT(INOUT)  :: C(:)

    INTEGER  :: i

->>- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {>ATOM:C}
      C({%RTIND}(:)) = I12C(:) + I13C(:)
-<<- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {<ATOM:C}
->>- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {>ATOM:O}
      C({%RTIND}(:)) = I16O(:) + I17O(:) + I18O(:)
-<<- תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת {<ATOM:O}

#ifdef DEBUG
    print *,'{%TAG}_correct2iso: working'
#endif 

  END SUBROUTINE {%TAG}_correct2iso



! - some cfg cheks ------------------------------------------------------------

#ifndef INT_LINMAX
#ifndef INT_SIMEULER
#ifndef INT_CASHKARP
 FATAL: no integration method choosed
#endif
#endif
#endif

! ---------------------------------------------------------------------------

END MODULE {%CMODEL}_{%TAG}

! ***************************************************************************

